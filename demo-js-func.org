* Functions in JS
** Functions in JavaScript are blocks of reusable code.
A Function
+ A block of reusable code that performs a specific task.
+ Defined using the function keyword or as arrow functions in ES6.

#+begin_src js
 myFunction(param1, param2) {
  // function body
  return param1 + param2;
}
#+end_src

+ Arguments: Inputs passed to the function.
+ Return Value: The output generated by the function.

** Types of Functions
*** Named Functions
Example:
#+begin_src js
function greet(name) {
  return `Hello, ${name}`;
}
#+end_src

** Arrow Functions (ES6)
- Shorter Syntax for writing functions.

**** Example:
 
#+begin_src js
  const add = (a, b) => a + b;
  console.log(add(3, 4)); // 7
  #+end_src

****Advantages:
  - Concise syntax.
  - Lexical `this` binding.

** First-Class Functions
- **Functions are First-Class Citizens** in JavaScript.
  - Functions can be:
    - Assigned to variables.
    - Passed as arguments to other functions.
    - Returned from other functions.

**** Example:
  #+begin_src jsjavascript
  function callFunction(func) {
    return func();
  }
  #+end_src

** Higher-Order Functions
***What are Higher-Order Functions?**
  - Functions that can take other functions as arguments or return a function.
**** Examples:
  - `map()`, `filter()`, `reduce()`:

    #+begin_src jsjavascript
    const numbers = [1, 2, 3, 4];
    const doubled = numbers.map(n => n * 2); // [2, 4, 6, 8]
    #+end_src js

**Pure Functions
***What is a Pure Function?
  - A function that has no side effects and always returns the same output given the same input.
**** Example:
  #+begin_src jsjavascript
  function multiply(a, b) {
    return a * b; // no external state modification
  }
  #+end_src js

** Immutability
***Functional Programming Emphasizes Immutability:**
  - Data is not modified but rather new data is created.
 **** Example:
    #+begin_src jsjavascript
    const numbers = [1, 2, 3];
    const newNumbers = [...numbers, 4]; // original array stays intact
    #+end_src

_Why Important?_Ensures code is more predictable and less prone to errors.

---

**Closures
***Closures**: A function that retains access to variables from its outer scope, even after the outer function has finished executing.
**** Example:
  #+begin_src jsjavascript
  function outer() {
    let count = 0;
    return function inner() {
      count++;
      return count;
    }
  }
  const counter = outer();
  console.log(counter()); // 1
  console.log(counter()); // 2
  #+end_src js

**Functional Programming in NodeJS
***Functional Programming Concepts in NodeJS:
  - Leveraging modules like `lodash` for functional utilities.
  
**** Example of chaining functional methods:
    #+begin_src jsjavascript
    const _ = require('lodash');
    const arr = [1, 2, 3, 4];
    const result = _.chain(arr)
      .map(n => n * 2)
      .filter(n => n > 4)
      .value(); // [6, 8]
    #+end_src js

** Recap and Final Thoughts
*** key Takeaways:
  - Functions are core building blocks in JavaScript.
  - Functional programming emphasizes immutability, pure functions, and higher-order functions.
  - JavaScript supports both imperative and functional programming styles.
*** Next Steps:
  - Explore more on functional libraries like `Ramda` and `Lodash`.
  - Hands-on coding practice with higher-order functions and immutability.

** Suggested Hands-On Exercises:
1. Write a pure function that computes the factorial of a number.
2. Use `map()`, `filter()`, and `reduce()` to manipulate an array of numbers.
3. Implement a closure to create a simple counter.
